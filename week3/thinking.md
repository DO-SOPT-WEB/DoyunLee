리액트를 사용하는 가장 주된 이유는?!

- 컴포넌트의 재사용이 가능하고 컴포넌트를 나눔으로써 복잡성을 줄일 수 있기 때문!

컴포넌트는 어떤 기준과 방법으로 분리하는 것이 좋을까?

- 재사용이 많이 일어나는 코드가 있다면 컴포넌트로 분리하는게 좋음!
  - 재사용이 많이 일어난다는 것은 그만큼 일반적이라는 것
- 코드가 복잡하다면 가독성과 유지보수의 용이성을 위해 컴포넌트를 분리하는 것이 좋음!
- 하나의 컴포넌트에는 하나의 책임만 부여하기 (한가지 역할만..으로 이해했음)
  - 코드의 복잡성과도 이어진다고 생각하는데, 코드가 복잡하다는 것은 그만큼 하는 기능이 많다는 것이므로 다수의 책임을 부여한다고 이해함
- 하나의 컴컴포넌트 안에서 서로 영향을 주지 않는 상태가 많이 존재할 경우, 렌더링이 효율적이 못할 수 있으므로 나누는 것이 좋음!

좋은 상태 관리란 무엇일까?

- 좋다 = 효과적으로 관리하고 유지할 수 있다?!
- 프로젝트의 규모가 커질수록 / 복잡성이 증가할수록 컴포넌트 간의 다양한 데이터 공유가 일어날 때 더욱 중요함!
- 상태관리가 효과적이지 못하면 유지보수가 어려울 수 있음

결국,

1. 상태의 흐름이 예측 가능해야 하며, 디버깅이 쉬워야 한다!
2. 프로젝트의 규모가 커지더라도 상태관리 체계 또한 같이 쉽게 커져야 한다!
3. 코드를 쉽게 이해하고 유지보수를 할 수 있어야 한다!

렌더링을 효과적으로 관리하는 방법은 무엇이 있을까?

- 다양한 상태 관리 라이브러리가 존재함! (Recoil, Redux, MobX, Zustand, Jotai, Valtio 등)..
- `ustState` - 함수 컴포넌트 내에서 로컬 상태를 관리하는데 사용되며, 간단한 컴포넌트나 로컬 상태만 필요한 경우에 유용함
- `useMemo` - 컴포넌트 메모이제이션을 통해 함수나 연산 결과를 기억함으로써 중복 계산을 피할 수 있음
  - 계산이 된다는 것은 업데이트가 된다는 것이므로 계산 될 때마다 리렌더링 됨
- `useCallback` - 값을 반환하는 것이 아니라 메모이제이션 된 콜백함수를 다시 반환
  - deps 안에 있는 값이 변화하지 않으면, 첫번째 인자로 전달한 콜백함수를 계속해서 재사용 할 수 있도록 도와줌
- `useReducer` - `useState`를 대체할 수 있는 기능으로, useState를 사용하듯이 배열을 반환함

Props Drilling이란 무엇이고 이를 어떻게 해결할 수 있는가?

- props을 하위 컴포넌트로 전달하는 용도로만 쓰이는 컴포넌트들을 거치며 데이터를 전달하는 것
- 전달만 하는 컴포넌트가 많이 생기게 된다면 props의 이름을 변경하기 어려워지고, 코드 작성과 수정에 악영향을 끼치게 됨
- 해결법 1: 전역 상태관리 라이브러리 사용
- 해결법 2: `contextAPI` 사용
